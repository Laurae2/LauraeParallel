% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/LauraeLapply.R
\name{LauraeLapply}
\alias{LauraeLapply}
\alias{LauraeParallel.init}
\alias{LauraeParallel.worker}
\title{Laurae's Parallel Apply with Load Balancing}
\usage{
LauraeLapply(cl, x, fun, ...)

LauraeParallel.init(fun, ...)

LauraeParallel.worker(x)
}
\arguments{
\item{cl}{Type: cluster. It must be created by \code{snow}.}

\item{x}{Type: vector (atomic or list).}

\item{fun}{Type: function to parallelize.}

\item{...}{More parameters to pass to the function.}
}
\value{
A list of elements.
}
\description{
This function performs \code{parallel::parLapply} with proper load balancing (OpenMP-like pragma guided/dynamic instead of pragma static in \code{parallel::parLapply}).
}
\details{
Pragma guided/dynamic works very well for long tasks which have dynamic computation time (such as machine learning tasks on large data). However, it becomes very poor when data is computed very quickly, as the overhead increases dramatically. With the default \code{parallel::parLapply}, data is chunk for each worker first, then submitted (static pragma), which makes it significantly faster on smaller data.

Please check the example to understand the difference between guided/dynamic pragma and static pragma scheduling for parallelization.
}
\examples{

library(parallel)
cl <- makeCluster(2)

# Set this to 1 for more realistic testing...
airman_speedtest <- 0.1

# Guided/Dynamic scheduling: 12 Seconds
# Preparation: none
# 00s => start 1, start 2
# 01s => end 1, start 3
# 02s => end 2, start 4
# 04s => end 3, start 5
# 06s => end 4, start 6
# 08s => end 5
# 12s => end 6
system.time({LauraeLapply(cl, (1:6) * airman_speedtest, function(x) {
  Sys.sleep(x)
  return(x)
})})

# Static scheduling: 15 Seconds
# Preparation: chunk in two:
# -- Worker 1: 1, 2, 3
# -- Worker 2: 4, 5, 6
# 00s => start 1, start 4
# 01s => end 1, start 2
# 03s => end 2, start 3
# 04s => end 4, start 5
# 06s => end 3
# 09s => end 5, start 6
# 15s => end 6
system.time({parLapply(cl, (1:6) * airman_speedtest, function(x) {
  Sys.sleep(x)
  return(x)
})})

stopCluster(cl)
closeAllConnections()

}
